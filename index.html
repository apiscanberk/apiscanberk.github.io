<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Özmert Adana E5 Haritacılık (Stabil Sürüm)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen/dist/leaflet.fullscreen.css" />
    <style>
        :root {
            --brand-color: #0078d4; --success-color: #107c10; --danger-color: #d13438;
            --light-grey: #f0f0f0; --white: #fff; --shadow: 0 -2px 8px rgba(0,0,0,0.1);
        }
        body, html { 
            margin: 0; padding: 0; height: 100%; width: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            overflow: hidden; 
        }
        #app-container { display: flex; flex-direction: column; height: 100%; }
        #map { flex-grow: 1; background: #e9e9e9; }
        #bottom-panel {
            background-color: var(--light-grey);
            box-shadow: var(--shadow);
            border-top: 1px solid #ccc;
            flex-shrink: 0; /* Panelin küçülmesini engelle */
        }
        #info-container {
            display: flex; justify-content: space-around;
            gap: 10px; padding: 10px; text-align: center;
        }
        .info-box {
            background-color: var(--white); border-radius: 8px;
            padding: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex: 1;
        }
        .info-box .label { font-size: 0.9em; color: #555; font-weight: 600; }
        .info-box .value { 
            color: var(--brand-color); font-size: 1.6em; 
            margin-top: 5px; font-weight: 700;
        }
        .info-box .value.error { color: var(--danger-color); }
        #controls-container {
            display: flex; align-items: stretch;
            padding: 10px; gap: 10px; border-top: 1px solid #ddd;
        }
        .control-group { flex-grow: 1; display: flex; gap: 5px; }
        .control-input {
            width: 100%; border: 1px solid #ccc; border-radius: 8px; 
            padding: 12px; font-size: 1.1em; text-align: center;
        }
        #gpsButton, .control-button {
            padding: 0 20px; font-size: 1.1em; font-weight: bold; color: white;
            border: none; border-radius: 8px; cursor: pointer;
            transition: background-color 0.3s;
        }
        #goToKmBtn { background-color: var(--brand-color); }
        #gpsButton { background-color: var(--success-color); }
        #gpsButton:disabled { background-color: #6c757d; cursor: not-allowed; }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="map"></div>
        <div id="bottom-panel">
            <div id="info-container">
                <div class="info-box">
                    <div class="label">Kilometre</div>
                    <span class="value" id="kilometre">--.--</span>
                </div>
                 <div class="info-box">
                    <div class="label">Ofset</div>
                    <span class="value" id="ofset">--.--</span>
                </div>
            </div>
            <div id="controls-container">
                <div class="control-group">
                    <input type="number" id="km-input" class="control-input" placeholder="KM'ye Git (Örn: 22.5)">
                    <button id="goToKmBtn" class="control-button">Git</button>
                </div>
                <button id="gpsButton">Başlat</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.fullscreen/dist/Leaflet.fullscreen.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            // DEĞİŞKENLER
            const map = L.map('map', { fullscreenControl: true, contextmenu: true }).setView([37.0, 35.3], 13);
            const kilometreElement = document.getElementById('kilometre'), ofsetElement = document.getElementById('ofset');
            const gpsButton = document.getElementById('gpsButton'), kmInput = document.getElementById('km-input'), goToKmBtn = document.getElementById('goToKmBtn');
            let userMarker, routePolyline, startStation, manualMarker, gpsWatcherId;

            // HARİTA KATMANLARI
            const baseLayers = {
                "Sokak": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '© OpenStreetMap' }).addTo(map),
                "Uydu": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 19, attribution: '© Esri' })
            };
            L.control.layers(baseLayers).addTo(map);
            
            // PROJEKSİYON TANIMI
            proj4.defs("EPSG:5258", "+proj=tmerc +lat_0=0 +lon_0=36 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

            // --- ANA BAŞLATMA FONKSİYONU ---
            async function initialize() {
                try {
                    const response = await fetch('ADANA-CEYHAN_REV1.xml');
                    if (!response.ok) throw new Error('XML dosyası bulunamadı!');
                    const xmlText = await response.text();
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                    
                    const alignment = xmlDoc.querySelector('Alignment');
                    if (!alignment) throw new Error('XML dosyasında güzergah bilgisi (Alignment) bulunamadı.');
                    startStation = parseFloat(alignment.getAttribute('staStart'));
                    
                    let routePoints = [];
                    for (const element of alignment.querySelector('CoordGeom').children) {
                        routePoints.push(...parseElement(element));
                    }
                    routePolyline = L.polyline(routePoints, { color: 'red', weight: 5 }).addTo(map);
                    map.fitBounds(routePolyline.getBounds());
                    
                    // Olay dinleyicilerini ekle
                    gpsButton.addEventListener('click', toggleGps);
                    goToKmBtn.addEventListener('click', goToKm);
                } catch (error) {
                    alert(`Kritik Hata: ${error.message}`);
                    gpsButton.disabled = true;
                    goToKmBtn.disabled = true;
                }
            }

            // --- GPS FONKSİYONLARI ---
            function toggleGps() {
                if (gpsWatcherId) {
                    navigator.geolocation.clearWatch(gpsWatcherId);
                    gpsWatcherId = null;
                    gpsButton.textContent = "Başlat";
                    gpsButton.style.backgroundColor = 'var(--success-color)';
                } else {
                    startGpsTracking();
                }
            }

            function startGpsTracking() {
                if (!navigator.geolocation) { alert("GPS Desteklenmiyor"); return; }
                gpsButton.textContent = "Bağlanılıyor..."; gpsButton.disabled = true;

                gpsWatcherId = navigator.geolocation.watchPosition(
                    (position) => {
                        gpsButton.textContent = "Durdur";
                        gpsButton.disabled = false;
                        gpsButton.style.backgroundColor = 'var(--danger-color)';
                        
                        const userLatLng = L.latLng(position.coords.latitude, position.coords.longitude);
                        
                        if (!userMarker) {
                            userMarker = L.circleMarker(userLatLng, { radius: 8, color: 'blue', fillColor: '#3388ff', fillOpacity: 0.8 }).addTo(map);
                        } else {
                            userMarker.setLatLng(userLatLng);
                        }
                        map.setView(userLatLng, 18);
                        updateCalculations(userLatLng);
                    }, 
                    (error) => {
                        alert("GPS sinyali alınamadı veya izin reddedildi.");
                        toggleGps(); // GPS'i durdur
                    }, 
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );
            }

            // --- HESAPLAMA FONKSİYONLARI (EN SAĞLAM HALİ) ---
            function updateCalculations(userLatLng) {
                kilometreElement.classList.remove('error');
                
                if (!routePolyline || !userLatLng) return;

                const closest = findClosestPointOnPolyline(userLatLng, routePolyline);
                
                // Güvenlik kontrolü: Eğer en yakın nokta bulunamazsa, "Güzergah Dışı" yaz ve çık
                if (!closest || closest.point === null || closest.segmentIndex < 0) {
                    kilometreElement.textContent = "Güzergah Dışı";
                    ofsetElement.textContent = "--.--";
                    kilometreElement.classList.add('error');
                    return;
                }

                const distance = calculateDistanceAlongPolyline(closest, routePolyline);
                if (isNaN(distance)) {
                    kilometreElement.textContent = "Hesaplama Hatası";
                    kilometreElement.classList.add('error');
                    return;
                }
                
                const currentKm = startStation + distance;
                kilometreElement.textContent = `${(currentKm / 1000).toFixed(3)}`;
                ofsetElement.textContent = `${closest.direction} ${closest.offset.toFixed(1)}m`;
            }
            
            function findClosestPointOnPolyline(latlng, polyline) {
                const latLngs = polyline.getLatLngs();
                if (!latLngs || latLngs.length < 2) return { point: null, segmentIndex: -1 };

                let minDistance = Infinity;
                let closestResult = { point: null, segmentIndex: -1 };

                for (let i = 0; i < latLngs.length - 1; i++) {
                    const p1 = latLngs[i], p2 = latLngs[i+1];
                    const dx = p2.lng - p1.lng, dy = p2.lat - p1.lat;
                    if (dx === 0 && dy === 0) continue;

                    const t = ((latlng.lng - p1.lng) * dx + (latlng.lat - p1.lat) * dy) / (dx * dx + dy * dy);
                    let closestPointOnSegment = (t < 0) ? p1 : (t > 1) ? p2 : L.latLng(p1.lat + t * dy, p1.lng + t * dx);
                    
                    const dist = latlng.distanceTo(closestPointOnSegment);
                    if (dist < minDistance) {
                        minDistance = dist;
                        const crossProduct = (p2.lng - p1.lng) * (latlng.lat - p1.lat) - (p2.lat - p1.lat) * (latlng.lng - p1.lng);
                        closestResult = { 
                            point: closestPointOnSegment, 
                            segmentIndex: i, 
                            offset: minDistance, 
                            direction: Math.abs(crossProduct) < 1e-9 ? 'Üzerinde' : crossProduct > 0 ? 'Sağ' : 'Sol' 
                        };
                    }
                }
                return closestResult;
            }

            function calculateDistanceAlongPolyline({ point, segmentIndex }, polyline) {
                if (!point || typeof segmentIndex !== 'number' || segmentIndex < 0) return NaN;
                
                let distance = 0;
                const latLngs = polyline.getLatLngs();
                for (let i = 0; i < segmentIndex; i++) {
                    distance += latLngs[i].distanceTo(latLngs[i+1]);
                }
                distance += latLngs[segmentIndex].distanceTo(point);
                return distance;
            }

            // --- YARDIMCI FONKSİYONLAR ---
            function goToKm() {
                const kmValue = parseFloat(kmInput.value);
                if (isNaN(kmValue)) return;
                const km = kmValue * 1000;
                
                if(manualMarker) map.removeLayer(manualMarker);
                
                let distance = 0;
                const latLngs = routePolyline.getLatLngs();
                for (let i = 0; i < latLngs.length - 1; i++) {
                    const p1 = latLngs[i], p2 = latLngs[i+1];
                    const segmentDist = p1.distanceTo(p2);
                    if (distance + segmentDist >= (km - startStation)) {
                        const ratio = (km - startStation - distance) / segmentDist;
                        const targetLat = p1.lat + ratio * (p2.lat - p1.lat);
                        const targetLng = p1.lng + ratio * (p2.lng - p1.lng);
                        const targetPoint = L.latLng(targetLat, tLng);
                        manualMarker = L.marker(targetPoint).addTo(map).bindPopup(`KM: ${kmValue.toFixed(3)}`).openPopup();
                        map.setView(targetPoint, 18);
                        return;
                    }
                    distance += segmentDist;
                }
                alert("Girilen KM güzergah dışında!");
            }

            function parseElement(element) {
                let p = [];
                if (element.tagName === 'Line') {
                    const s = element.querySelector('Start').textContent.trim().split(' ').map(Number);
                    const e = element.querySelector('End').textContent.trim().split(' ').map(Number);
                    p.push(proj4('EPSG:5258', 'WGS84', [s[1], s[0]]), proj4('EPSG:5258', 'WGS84', [e[1], e[0]]));
                } else if (element.tagName === 'Curve') {
                    const s = element.querySelector('Start').textContent.trim().split(' ').map(Number);
                    const c = element.querySelector('Center').textContent.trim().split(' ').map(Number);
                    const r = parseFloat(element.getAttribute('radius'));
                    const rot = element.getAttribute('rot');
                    const sA = Math.atan2(s[0] - c[0], s[1] - c[1]);
                    const e = element.querySelector('End').textContent.trim().split(' ').map(Number);
                    const eA = Math.atan2(e[0] - c[0], e[1] - c[1]);
                    let aD = eA - sA;
                    if (rot === 'cw' && aD > 0) aD -= 2 * Math.PI;
                    if (rot === 'ccw' && aD < 0) aD += 2 * Math.PI;
                    const nS = Math.max(10, Math.ceil(Math.abs(aD * r) / 5));
                    for (let i = 0; i <= nS; i++) {
                        const angle = sA + (aD * i) / nS;
                        p.push(proj4('EPSG:5258', 'WGS84', [c[1] + r * Math.cos(angle), c[0] + r * Math.sin(angle)]));
                    }
                }
                return p.map(pt => [pt[1], pt[0]]);
            }
            
            // UYGULAMAYI BAŞLAT
            initialize();
        });
    </script>
</body>
</html>
