<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Ã–zmert Adana E5 HaritacÄ±lÄ±k</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen/dist/leaflet.fullscreen.css" />
    <style>
        :root {
            --brand-color: #0078d4; --success-color: #107c10; --danger-color: #d13438;
            --dark-grey: #2b2b2b; --light-grey: #f0f0f0; --white: #fff;
            --shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        body, html { 
            margin: 0; padding: 0; height: 100%; width: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            overflow: hidden; background-color: var(--light-grey);
        }
        #app-container { display: flex; flex-direction: column; height: 100vh; }
        #map { flex-grow: 1; background: #e9e9e9; cursor: crosshair; }
        #bottom-panel {
            background-color: var(--light-grey);
            box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
            border-top: 1px solid #ddd;
            display: flex; flex-direction: column;
            max-height: 45vh;
        }
        #info-container {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px; padding: 8px; text-align: center;
        }
        .info-box {
            background-color: var(--white); border-radius: 10px;
            padding: 8px; box-shadow: var(--shadow);
            font-size: clamp(0.8em, 2.5vw, 1em);
        }
        .info-box .label { font-size: 0.8em; color: #555; font-weight: 600; }
        .info-box .value { 
            color: var(--brand-color); font-size: 1.4em; 
            margin-top: 4px; font-weight: 700;
        }
        .info-box .value.kazÄ± { color: var(--brand-color); }
        .info-box .value.dolgu { color: var(--danger-color); }

        #controls-container {
            display: flex; align-items: stretch; justify-content: space-between;
            padding: 8px; gap: 8px; border-top: 1px solid #ddd;
        }
        #aplikasyon-container { flex-grow: 1; display: flex; gap: 5px; }
        .aplikasyon-input {
            width: 100%; border: 1px solid #ccc; border-radius: 8px; 
            padding: 10px; font-size: 1em; text-align: center;
        }
        #gpsButton {
            width: 130px; padding: 10px; font-size: 1em;
            font-weight: bold; color: white; background-color: var(--success-color); 
            border: none; border-radius: 8px; cursor: pointer;
            box-shadow: var(--shadow); transition: background-color 0.3s;
        }
        #gpsButton:disabled { background-color: #6c757d; cursor: not-allowed; }
        
        /* Harita Ã¼zerindeki butonlar */
        #follow-toggle {
            position: absolute; bottom: 48vh; right: 10px; z-index: 1000; 
            background: var(--white); border: 2px solid rgba(0,0,0,0.2);
            border-radius: 50%; width: 40px; height: 40px; font-size: 1.8em;
            cursor: pointer; box-shadow: var(--shadow); display: flex;
            align-items: center; justify-content: center;
        }
        #follow-toggle.active { background-color: var(--brand-color); color: var(--white); }
        
        /* Enkesit Stili */
        #cross-section-container {
            height: 20vh; background-color: var(--white);
            border-top: 1px solid #ddd; padding: 5px; box-sizing: border-box;
        }
        #cross-section-canvas { width: 100%; height: 100%; }
        
        /* Crosshair Info Box */
        #crosshair-info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
            z-index: 1000;
            pointer-events: none; /* Ãœzerine tÄ±klanmasÄ±nÄ± engelle */
            display: none; /* BaÅŸlangÄ±Ã§ta gizli */
        }
        
        /* Rapor ModalÄ± */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 2000; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.4); 
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 10px;
        }
        .modal-content input, .modal-content textarea {
            width: 95%;
            padding: 10px;
            margin-top: 5px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="map"></div>
        <div id="crosshair-info"></div>
        <div id="bottom-panel">
            <div id="cross-section-container">
                <canvas id="cross-section-canvas"></canvas>
            </div>
            <div id="info-container">
                <div class="info-box">
                    <div class="label">KM</div>
                    <span class="value" id="kilometre">--.--</span>
                </div>
                 <div class="info-box">
                    <div class="label">Ofset</div>
                    <span class="value" id="ofset">--.--</span>
                </div>
                <div class="info-box">
                    <div class="label">Proje Kotu</div>
                    <span class="value" id="proje-kotu">--.-- m</span>
                </div>
                 <div class="info-box">
                    <div class="label">GPS Kotu / Fark</div>
                    <span class="value" id="gps-kotu">--.-- m</span>
                </div>
            </div>
            <div id="controls-container">
                <div id="aplikasyon-container">
                    <input type="number" id="km-input" class="aplikasyon-input" placeholder="KM Gir (Ã¶rn: 22123.45)">
                    <input type="number" id="offset-input" class="aplikasyon-input" placeholder="Ofset Gir (Ã¶rn: -8.5)">
                    <button id="goToKmBtn">Git</button>
                </div>
                <button id="gpsButton">BaÅŸlat</button>
            </div>
        </div>
    </div>
    <div id="follow-toggle" class="active" title="Otomatik Takip">ðŸŽ¯</div>
    
    <div id="reportModal" class="modal">
      <div class="modal-content">
        <h3>Rapor OluÅŸtur</h3>
        <label for="report-km-start">KM BaÅŸlangÄ±cÄ±</label>
        <input type="text" id="report-km-start" readonly>
        <label for="report-km-end">KM Sonu</label>
        <input type="number" id="report-km-end" placeholder="BitiÅŸ KM'si">
        <label for="report-work">YapÄ±lan Ä°ÅŸ</label>
        <textarea id="report-work" rows="3" placeholder="Ã–rn: KazÄ± yapÄ±ldÄ±, bordÃ¼r dÃ¶ÅŸendi..."></textarea>
        <div class="modal-buttons">
            <button id="cancelReport">Ä°ptal</button>
            <button id="saveReport">Kaydet</button>
        </div>
      </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.fullscreen/dist/Leaflet.fullscreen.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            // DeÄŸiÅŸken TanÄ±mlamalarÄ±
            const map = L.map('map', { fullscreenControl: true }).setView([37.0, 35.3], 13);
            const kilometreElement = document.getElementById('kilometre'), ofsetElement = document.getElementById('ofset');
            const gpsButton = document.getElementById('gpsButton'), followToggle = document.getElementById('follow-toggle');
            const kmInput = document.getElementById('km-input'), offsetInput = document.getElementById('offset-input'), goToKmBtn = document.getElementById('goToKmBtn');
            const projeKotuElement = document.getElementById('proje-kotu'), gpsKotuElement = document.getElementById('gps-kotu');
            const canvas = document.getElementById('cross-section-canvas'), ctx = canvas.getContext('2d');
            const crosshairInfo = document.getElementById('crosshair-info');
            const reportModal = document.getElementById('reportModal'), saveReportBtn = document.getElementById('saveReport'), cancelReportBtn = document.getElementById('cancelReport');
            let userMarker, routePolyline, startStation, connectionLine, crossSections = new Map(), isFollowing = true, manualMarker, gpsWatcherId;

            // Harita KatmanlarÄ±
            const baseLayers = {
                "Sokak": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: 'Â© OpenStreetMap' }).addTo(map),
                "Uydu": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 19, attribution: 'Â© Esri' }),
                "Arazi": L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17, attribution: 'Â© OpenTopoMap' })
            };
            L.control.layers(baseLayers).addTo(map);
            
            proj4.defs("EPSG:5258", "+proj=tmerc +lat_0=0 +lon_0=36 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

            async function initialize() {
                try {
                    const response = await fetch('ADANA-CEYHAN_REV1.xml');
                    if (!response.ok) throw new Error('XML dosyasÄ± bulunamadÄ±! LÃ¼tfen index.html ile aynÄ± klasÃ¶rde olduÄŸundan emin olun.');
                    const xmlText = await response.text();
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                    
                    const alignment = xmlDoc.querySelector('Alignment');
                    startStation = parseFloat(alignment.getAttribute('staStart'));
                    
                    xmlDoc.querySelectorAll('CrossSect').forEach(cs => {
                        const sta = parseFloat(cs.getAttribute('sta'));
                        const pntList = cs.querySelector('PntList2D').textContent.trim().split(' ').map(Number);
                        const points = [];
                        for (let i = 0; i < pntList.length; i += 2) points.push({ x: pntList[i], y: pntList[i+1] });
                        if(points.length > 1) crossSections.set(sta, points);
                    });

                    let routePoints = [];
                    for (const element of alignment.querySelector('CoordGeom').children) {
                        routePoints.push(...parseElement(element));
                    }
                    routePolyline = L.polyline(routePoints, { color: 'red', weight: 5 }).addTo(map);
                    map.fitBounds(routePolyline.getBounds());
                    
                    gpsButton.addEventListener('click', toggleGps);
                    followToggle.addEventListener('click', () => { isFollowing = !isFollowing; followToggle.classList.toggle('active', isFollowing); });
                    goToKmBtn.addEventListener('click', goToKm);
                    map.on('mousemove', onMapMouseMove);
                    map.on('contextmenu', onMapRightClick); // Uzun basma iÃ§in
                } catch (error) {
                    alert(`Kritik Hata: ${error.message}`);
                }
            }

            // ... (TÃ¼m diÄŸer fonksiyonlar buraya eklenecek)
            
            // Crosshair Info Box Logic
            function onMapMouseMove(e) {
                const latlng = e.latlng;
                const closest = findClosestPointOnPolyline_Robust(latlng, routePolyline);
                const km = startStation + calculateDistanceAlongPolyline(closest, routePolyline);
                crosshairInfo.style.display = 'block';
                crosshairInfo.style.left = e.containerPoint.x + 'px';
                crosshairInfo.style.top = e.containerPoint.y - 30 + 'px';
                crosshairInfo.innerHTML = `KM: ${(km / 1000).toFixed(3)} | Ofset: ${closest.direction} ${closest.offset.toFixed(1)}m`;
            }

            // Raporlama Logic
            function onMapRightClick(e) {
                e.originalEvent.preventDefault(); // TarayÄ±cÄ±nÄ±n saÄŸ tÄ±k menÃ¼sÃ¼nÃ¼ engelle
                const latlng = e.latlng;
                const closest = findClosestPointOnPolyline_Robust(latlng, routePolyline);
                const km = startStation + calculateDistanceAlongPolyline(closest, routePolyline);
                
                L.popup()
                    .setLatLng(latlng)
                    .setContent('<button id="addReportBtn">Rapora Ekle</button>')
                    .openOn(map);
                
                document.getElementById('addReportBtn').onclick = function() {
                    map.closePopup();
                    openReportModal(km);
                };
            }
            
            function openReportModal(km) {
                document.getElementById('report-km-start').value = (km / 1000).toFixed(3);
                reportModal.style.display = "block";
            }
            
            cancelReportBtn.onclick = () => reportModal.style.display = "none";
            saveReportBtn.onclick = () => {
                // Burada raporu kaydetme ve gÃ¶sterme iÅŸlemleri yapÄ±lacak
                alert("Rapor Kaydedildi (Bu Ã¶zellik geliÅŸtirme aÅŸamasÄ±ndadÄ±r).");
                reportModal.style.display = "none";
            };

            // ... (Ã–nceki versiyondaki tÃ¼m diÄŸer fonksiyonlar)
            
            function toggleGps() {
                if (gpsWatcherId) {
                    navigator.geolocation.clearWatch(gpsWatcherId);
                    gpsWatcherId = null;
                    gpsButton.textContent = "BaÅŸlat";
                    gpsButton.style.backgroundColor = 'var(--success-color)';
                } else {
                    startGpsTracking();
                }
            }

            function startGpsTracking() {
                if (!navigator.geolocation) { alert("GPS Desteklenmiyor"); return; }
                gpsButton.textContent = "BaÄŸlanÄ±lÄ±yor..."; gpsButton.disabled = true;

                gpsWatcherId = navigator.geolocation.watchPosition((position) => {
                    gpsButton.textContent = "Durdur"; gpsButton.disabled = false;
                    gpsButton.style.backgroundColor = 'var(--danger-color)';
                    const { latitude, longitude, altitude } = position.coords;
                    const userLatLng = L.latLng(latitude, longitude);
                    
                    if (!userMarker) {
                        userMarker = L.circleMarker(userLatLng, { radius: 8, color: 'blue', fillColor: '#3388ff', fillOpacity: 0.8 }).addTo(map);
                        map.setView(userLatLng, 18);
                    } else {
                        userMarker.setLatLng(userLatLng);
                    }
                    if (isFollowing) map.panTo(userLatLng);
                    updateCalculations(userLatLng, altitude);
                }, (error) => {
                    alert("GPS sinyali alÄ±namadÄ±."); gpsButton.textContent = "Tekrar Dene"; gpsButton.disabled = false;
                }, { enableHighAccuracy: true });
            }
            
            function updateCalculations(userLatLng, userAltitude) {
                try {
                    const closest = findClosestPointOnPolyline_Robust(userLatLng, routePolyline);
                    const currentKm = startStation + calculateDistanceAlongPolyline(closest, routePolyline);
                    const projectElevation = getProjectElevation(currentKm, closest.offset);
                    const elevationDiff = userAltitude ? userAltitude - projectElevation : null;
                    
                    kilometreElement.textContent = `${(currentKm / 1000).toFixed(3)}`;
                    ofsetElement.textContent = `${closest.direction} ${closest.offset.toFixed(1)}m`;
                    projeKotuElement.textContent = `${projectElevation.toFixed(2)} m`;

                    if (elevationDiff !== null) {
                        gpsKotuElement.textContent = `${userAltitude.toFixed(2)}m | ${elevationDiff > 0 ? 'Dolgu' : 'KazÄ±'}: ${Math.abs(elevationDiff).toFixed(2)}m`;
                        gpsKotuElement.className = `value ${elevationDiff > 0 ? 'dolgu' : 'kazÄ±'}`;
                    } else {
                        gpsKotuElement.textContent = "--.-- m";
                    }

                    if (connectionLine) map.removeLayer(connectionLine);
                    connectionLine = L.polyline([userLatLng, closest.point], { color: 'black', weight: 2, dashArray: '5, 10' }).addTo(map);

                    drawCrossSection(currentKm, closest.offset, userAltitude);
                } catch (e) {
                    kilometreElement.textContent = "Hesaplama HatasÄ±";
                }
            }

            function getProjectElevation(km, offset) {
                if (crossSections.size === 0) return 0;
                const stations = Array.from(crossSections.keys());
                const before = stations.filter(s => s <= km).pop() || stations[0];
                const after = stations.filter(s => s > km).shift() || stations[stations.length-1];
                if (before === after) return getElevAtOffset(crossSections.get(before), offset);

                const t = (km - before) / (after - before);
                const elevBefore = getElevAtOffset(crossSections.get(before), offset);
                const elevAfter = getElevAtOffset(crossSections.get(after), offset);
                return elevBefore + t * (elevAfter - elevBefore);
            }

            const getElevAtOffset = (points, off) => {
                let p1 = points.filter(p => p.x <= off).pop();
                let p2 = points.filter(p => p.x > off).shift();
                if (!p1 || !p2) return (p1 || p2).y;
                const tt = (off - p1.x) / (p2.x - p1.x);
                return p1.y + tt * (p2.y - p1.y);
            };

            function drawCrossSection(km, userOffset, userElevation) {
                 if (crossSections.size === 0) return;
                const stations = Array.from(crossSections.keys());
                const station = stations.reduce((prev, curr) => (Math.abs(curr - km) < Math.abs(prev - km) ? curr : prev));
                const points = crossSections.get(station);
                if (!points) return;

                const { width, height } = canvas;
                ctx.clearRect(0, 0, width, height);
                
                const minX = Math.min(...points.map(p=>p.x), userOffset || 0) - 2;
                const maxX = Math.max(...points.map(p=>p.x), userOffset || 0) + 2;
                const minY = Math.min(...points.map(p=>p.y)) - 2;
                const maxY = Math.max(...points.map(p=>p.y)) + 5;

                const scaleX = width / (maxX - minX);
                const scaleY = height / (maxY - minY);
                const scale = Math.min(scaleX, scaleY) * 0.8;

                const toCanvasX = (x) => (x - minX) * scale + (width - (maxX - minX) * scale) / 2;
                const toCanvasY = (y) => height - ((y - minY) * scale + (height - (maxY - minY) * scale) / 2);
                
                ctx.beginPath();
                ctx.moveTo(toCanvasX(points[0].x), toCanvasY(points[0].y));
                points.forEach(p => ctx.lineTo(toCanvasX(p.x), toCanvasY(p.y)));
                ctx.strokeStyle = "red"; ctx.lineWidth = 3; ctx.stroke();
                
                const eksenY = getProjectElevation(km, 0);
                ctx.beginPath();
                ctx.moveTo(toCanvasX(0), toCanvasY(eksenY - 1));
                ctx.lineTo(toCanvasX(0), toCanvasY(eksenY + 1));
                ctx.strokeStyle = "black"; ctx.lineWidth = 1; ctx.stroke();

                if (userOffset !== undefined && userElevation !== undefined) {
                    ctx.beginPath();
                    ctx.arc(toCanvasX(userOffset), toCanvasY(userElevation), 5, 0, 2 * Math.PI);
                    ctx.fillStyle = "blue"; ctx.fill();
                }
            }
            
            function goToKm() {
                const km = parseFloat(kmInput.value);
                const offset = parseFloat(offsetInput.value) || 0;
                if (isNaN(km)) return;

                if(manualMarker) map.removeLayer(manualMarker);
                
                let distance = 0;
                const latLngs = routePolyline.getLatLngs();
                for (let i = 0; i < latLngs.length - 1; i++) {
                    const p1 = latLngs[i], p2 = latLngs[i+1];
                    const segmentDist = p1.distanceTo(p2);
                    if (distance + segmentDist >= (km - startStation)) {
                        const ratio = (km - startStation - distance) / segmentDist;
                        const targetLat = p1.lat + ratio * (p2.lat - p1.lat);
                        const targetLng = p1.lng + ratio * (p2.lng - p1.lng);
                        
                        const bearing = Math.atan2(p2.lng - p1.lng, p2.lat - p1.lat);
                        const perpBearing = bearing + Math.PI / 2;
                        const R = 6378137;
                        const latOffset = offset * Math.cos(perpBearing) / R * (180 / Math.PI);
                        const lngOffset = offset * Math.sin(perpBearing) / (R * Math.cos(targetLat * Math.PI / 180)) * (180 / Math.PI);

                        const finalPoint = L.latLng(targetLat + latOffset, targetLng + lngOffset);
                        
                        manualMarker = L.marker(finalPoint, {
                            icon: L.divIcon({className: 'target-icon', html: '<b>X</b>', iconSize: [20, 20]})
                        }).addTo(map);

                        map.setView(finalPoint, 18);
                        break;
                    }
                    distance += segmentDist;
                }
            }
            
            function parseElement(element) {
                let points = [];
                if (element.tagName === 'Line') {
                    const start = element.querySelector('Start').textContent.trim().split(' ').map(Number);
                    const end = element.querySelector('End').textContent.trim().split(' ').map(Number);
                    points.push(proj4('EPSG:5258', 'WGS84', [start[1], start[0]]), proj4('EPSG:5258', 'WGS84', [end[1], end[0]]));
                } else if (element.tagName === 'Curve') {
                    const start = element.querySelector('Start').textContent.trim().split(' ').map(Number);
                    const center = element.querySelector('Center').textContent.trim().split(' ').map(Number);
                    const radius = parseFloat(element.getAttribute('radius'));
                    const rot = element.getAttribute('rot');
                    const startAngle = Math.atan2(start[0] - center[0], start[1] - center[1]);
                    const end = element.querySelector('End').textContent.trim().split(' ').map(Number);
                    const endAngle = Math.atan2(end[0] - center[0], end[1] - center[1]);
                    let angleDiff = endAngle - startAngle;
                    if (rot === 'cw' && angleDiff > 0) angleDiff -=
