<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Profesyonel GPS Navigasyon AracÄ±</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen/dist/leaflet.fullscreen.css" />
    <style>
        :root {
            --brand-color: #0078d4; --success-color: #107c10; --danger-color: #d13438;
            --dark-grey: #2b2b2b; --light-grey: #f0f0f0; --white: #fff;
            --shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        body, html { 
            margin: 0; padding: 0; height: 100%; width: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            overflow: hidden; background-color: var(--light-grey);
        }
        #app-container { display: flex; flex-direction: column; height: 100vh; }
        #map { flex-grow: 1; background: #e9e9e9; }
        #bottom-panel {
            background-color: var(--light-grey);
            box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
            border-top: 1px solid #ddd;
            display: flex; flex-direction: column;
            max-height: 40vh; /* Panelin maksimum yÃ¼ksekliÄŸi */
        }
        #info-container {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px; padding: 8px; text-align: center;
        }
        .info-box {
            background-color: var(--white); border-radius: 10px;
            padding: 8px; box-shadow: var(--shadow);
            font-size: clamp(0.8em, 2.5vw, 1em);
        }
        .info-box .label { font-size: 0.8em; color: #555; font-weight: 600; }
        .info-box .value { 
            color: var(--brand-color); font-size: 1.4em; 
            margin-top: 4px; font-weight: 700;
        }
        #controls-container {
            display: flex; align-items: center; justify-content: space-between;
            padding: 8px; gap: 8px; border-top: 1px solid #ddd;
        }
        #km-input-container { flex-grow: 1; display: flex; }
        #km-input {
            width: 100%; border: 1px solid #ccc; border-radius: 8px; 
            padding: 10px; font-size: 1em; text-align: center;
        }
        #gpsButton {
            width: 130px; padding: 10px; font-size: 1em;
            font-weight: bold; color: white; background-color: var(--success-color); 
            border: none; border-radius: 8px; cursor: pointer;
            box-shadow: var(--shadow); transition: background-color 0.3s;
        }
        #gpsButton:disabled { background-color: #6c757d; cursor: not-allowed; }
        
        /* Harita Ã¼zerindeki butonlar */
        .leaflet-control-layers-toggle { background-size: 20px 20px !important; }
        #follow-toggle {
            position: absolute; bottom: 42vh; right: 10px; z-index: 1000; 
            background: var(--white); border: 2px solid rgba(0,0,0,0.2);
            border-radius: 50%; width: 40px; height: 40px; font-size: 1.8em;
            cursor: pointer; box-shadow: var(--shadow); display: flex;
            align-items: center; justify-content: center;
        }
        #follow-toggle.active { background-color: var(--brand-color); color: var(--white); }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="map"></div>
        <div id="bottom-panel">
            <div id="info-container">
                <div class="info-box">
                    <div class="label">Kilometre</div>
                    <span class="value" id="kilometre">--.--</span>
                </div>
                 <div class="info-box">
                    <div class="label">Ofset</div>
                    <span class="value" id="ofset">--.--</span>
                </div>
                <div class="info-box">
                    <div class="label">Proje Kotu</div>
                    <span class="value" id="proje-kotu">--.-- m</span>
                </div>
                 <div class="info-box">
                    <div class="label">HÄ±z / Hassasiyet</div>
                    <span class="value" id="speed-accuracy">--.--</span>
                </div>
            </div>
            <div id="controls-container">
                <div id="km-input-container">
                    <input type="number" id="km-input" placeholder="KM'ye Git (Ã¶rn: 22.5)">
                </div>
                <button id="gpsButton">BaÅŸlat</button>
            </div>
        </div>
    </div>
    <div id="follow-toggle" class="active" title="Otomatik Takip">ðŸŽ¯</div>

    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.fullscreen/dist/Leaflet.fullscreen.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            // DeÄŸiÅŸken TanÄ±mlamalarÄ±
            const map = L.map('map', { fullscreenControl: true }).setView([37.0, 35.3], 13);
            const kilometreElement = document.getElementById('kilometre'), ofsetElement = document.getElementById('ofset');
            const gpsButton = document.getElementById('gpsButton'), followToggle = document.getElementById('follow-toggle');
            const kmInput = document.getElementById('km-input'), projeKotuElement = document.getElementById('proje-kotu');
            const speedAccuracyElement = document.getElementById('speed-accuracy');
            let userMarker, routePolyline, startStation, connectionLine, crossSections = new Map(), isFollowing = true, manualMarker, gpsWatcherId;

            // Harita KatmanlarÄ±
            const baseLayers = {
                "Sokak": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: 'Â© OpenStreetMap' }).addTo(map),
                "Uydu": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 19, attribution: 'Â© Esri' }),
                "Arazi": L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', { maxZoom: 17, attribution: 'Â© OpenTopoMap' })
            };
            L.control.layers(baseLayers).addTo(map);
            
            // Projeksiyon TanÄ±mÄ±
            proj4.defs("EPSG:5258", "+proj=tmerc +lat_0=0 +lon_0=36 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

            async function initialize() {
                try {
                    const response = await fetch('ADANA-CEYHAN_REV1.xml');
                    if (!response.ok) throw new Error('XML dosyasÄ± bulunamadÄ±!');
                    const xmlText = await response.text();
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                    
                    const alignment = xmlDoc.querySelector('Alignment');
                    startStation = parseFloat(alignment.getAttribute('staStart'));
                    
                    xmlDoc.querySelectorAll('CrossSect').forEach(cs => {
                        const sta = parseFloat(cs.getAttribute('sta'));
                        const pntList = cs.querySelector('PntList2D').textContent.trim().split(' ').map(Number);
                        const points = [];
                        for (let i = 0; i < pntList.length; i += 2) points.push({ x: pntList[i], y: pntList[i+1] });
                        crossSections.set(sta, points);
                    });

                    let routePoints = [];
                    for (const element of alignment.querySelector('CoordGeom').children) {
                        routePoints.push(...parseElement(element));
                    }
                    routePolyline = L.polyline(routePoints, { color: 'red', weight: 5 }).addTo(map);
                    map.fitBounds(routePolyline.getBounds());
                    
                    gpsButton.addEventListener('click', toggleGps);
                    followToggle.addEventListener('click', () => { isFollowing = !isFollowing; followToggle.classList.toggle('active', isFollowing); });
                    kmInput.addEventListener('keydown', e => { if (e.key === 'Enter') goToKm(); });

                } catch (error) {
                    alert(`Hata: ${error.message}`);
                }
            }

            function toggleGps() {
                if (gpsWatcherId) {
                    navigator.geolocation.clearWatch(gpsWatcherId);
                    gpsWatcherId = null;
                    gpsButton.textContent = "GPS'e BaÄŸlan";
                    gpsButton.style.backgroundColor = 'var(--success-color)';
                } else {
                    startGpsTracking();
                }
            }

            function startGpsTracking() {
                if (!navigator.geolocation) { alert("GPS Desteklenmiyor"); return; }
                gpsButton.textContent = "BaÄŸlanÄ±lÄ±yor..."; gpsButton.disabled = true;

                gpsWatcherId = navigator.geolocation.watchPosition((position) => {
                    gpsButton.textContent = "Durdur"; gpsButton.disabled = false;
                    gpsButton.style.backgroundColor = 'var(--danger-color)';
                    const { latitude, longitude, speed, accuracy } = position.coords;
                    const userLatLng = L.latLng(latitude, longitude);
                    
                    speedAccuracyElement.textContent = `${speed ? (speed * 3.6).toFixed(1) : '0.0'} km/s | Â±${accuracy.toFixed(1)}m`;

                    if (!userMarker) {
                        userMarker = L.circleMarker(userLatLng, { radius: 8, color: 'blue', fillColor: '#3388ff', fillOpacity: 0.8 }).addTo(map);
                        map.setView(userLatLng, 18);
                    } else {
                        userMarker.setLatLng(userLatLng);
                    }
                    if (isFollowing) map.panTo(userLatLng);
                    updateCalculations(userLatLng);
                }, (error) => {
                    alert("GPS sinyali alÄ±namadÄ±."); gpsButton.textContent = "Tekrar Dene"; gpsButton.disabled = false;
                }, { enableHighAccuracy: true });
            }

            function updateCalculations(userLatLng) {
                try {
                    const closest = findClosestPointOnPolyline_Robust(userLatLng, routePolyline);
                    const currentKm = startStation + calculateDistanceAlongPolyline(closest, routePolyline);
                    const projectElevation = getProjectElevation(currentKm, closest.offset);
                    
                    kilometreElement.textContent = `${(currentKm / 1000).toFixed(3)}`;
                    ofsetElement.textContent = `${closest.direction} ${closest.offset.toFixed(1)}m`;
                    projeKotuElement.textContent = `${projectElevation.toFixed(2)} m`;
                    
                    if (connectionLine) map.removeLayer(connectionLine);
                    connectionLine = L.polyline([userLatLng, closest.point], { color: 'black', weight: 2, dashArray: '5, 10' }).addTo(map);

                } catch (e) {
                    kilometreElement.textContent = "Hesaplama HatasÄ±";
                }
            }
            
            function getProjectElevation(km, offset) {
                if (crossSections.size === 0) return 0;
                const stations = Array.from(crossSections.keys());
                const before = stations.filter(s => s <= km).pop() || stations[0];
                const after = stations.filter(s => s > km).shift() || stations[stations.length-1];
                if (before === after) return getElevAtOffset(crossSections.get(before), offset);

                const t = (km - before) / (after - before);
                const elevBefore = getElevAtOffset(crossSections.get(before), offset);
                const elevAfter = getElevAtOffset(crossSections.get(after), offset);
                return elevBefore + t * (elevAfter - elevBefore);
            }

            const getElevAtOffset = (points, off) => {
                let p1 = points.filter(p => p.x <= off).pop();
                let p2 = points.filter(p => p.x > off).shift();
                if (!p1 || !p2) return (p1 || p2).y;
                const tt = (off - p1.x) / (p2.x - p1.x);
                return p1.y + tt * (p2.y - p1.y);
            };

            function goToKm() {
                const km = parseFloat(kmInput.value) * 1000;
                if (isNaN(km)) return;
                if(manualMarker) map.removeLayer(manualMarker);
                
                let distance = 0;
                const latLngs = routePolyline.getLatLngs();
                for (let i = 0; i < latLngs.length - 1; i++) {
                    const segmentDist = latLngs[i].distanceTo(latLngs[i+1]);
                    if (distance + segmentDist >= (km - startStation)) {
                        const ratio = (km - startStation - distance) / segmentDist;
                        const targetLat = latLngs[i].lat + ratio * (latLngs[i+1].lat - latLngs[i].lat);
                        const targetLng = latLngs[i].lng + ratio * (latLngs[i+1].lng - latLngs[i].lng);
                        const targetPoint = L.latLng(targetLat, targetLng);
                        manualMarker = L.marker(targetPoint).addTo(map);
                        map.setView(targetPoint, 18);
                        break;
                    }
                    distance += segmentDist;
                }
            }

            // Gerekli yardÄ±mcÄ± fonksiyonlar
            function parseElement(element) {
                let points = [];
                if (element.tagName === 'Line') {
                    const start = element.querySelector('Start').textContent.trim().split(' ').map(Number);
                    const end = element.querySelector('End').textContent.trim().split(' ').map(Number);
                    points.push(proj4('EPSG:5258', 'WGS84', [start[1], start[0]]), proj4('EPSG:5258', 'WGS84', [end[1], end[0]]));
                } else if (element.tagName === 'Curve') {
                    const start = element.querySelector('Start').textContent.trim().split(' ').map(Number);
                    const center = element.querySelector('Center').textContent.trim().split(' ').map(Number);
                    const radius = parseFloat(element.getAttribute('radius'));
                    const rot = element.getAttribute('rot');
                    const startAngle = Math.atan2(start[0] - center[0], start[1] - center[1]);
                    const end = element.querySelector('End').textContent.trim().split(' ').map(Number);
                    const endAngle = Math.atan2(end[0] - center[0], end[1] - center[1]);
                    let angleDiff = endAngle - startAngle;
                    if (rot === 'cw' && angleDiff > 0) angleDiff -= 2 * Math.PI;
                    if (rot === 'ccw' && angleDiff < 0) angleDiff += 2 * Math.PI;
                    const numSegments = Math.max(10, Math.ceil(Math.abs(angleDiff * radius) / 5));
                    for (let i = 0; i <= numSegments; i++) {
                        const angle = startAngle + (angleDiff * i) / numSegments;
                        points.push(proj4('EPSG:5258', 'WGS84', [center[1] + radius * Math.cos(angle), center[0] + radius * Math.sin(angle)]));
                    }
                }
                return points.map(p => [p[1], p[0]]);
            }

            function findClosestPointOnPolyline_Robust(latlng, polyline) {
                const latLngs = polyline.getLatLngs();
                let minDistance = Infinity;
                let closestResult = {};
                for (let i = 0; i < latLngs.length - 1; i++) {
                    const p1 = latLngs[i], p2 = latLngs[i+1];
                    const dx = p2.lng - p1.lng, dy = p2.lat - p1.lat;
                    if (dx === 0 && dy === 0) continue;
                    const t = ((latlng.lng - p1.lng) * dx + (latlng.lat - p1.lat) * dy) / (dx * dx + dy * dy);
                    let closestPointOnSegment = (t < 0) ? p1 : (t > 1) ? p2 : L.latLng(p1.lat + t * dy, p1.lng + t * dx);
                    const dist = latlng.distanceTo(closestPointOnSegment);
                    if (dist < minDistance) {
                        minDistance = dist;
                        const crossProduct = (p2.lng - p1.lng) * (latlng.lat - p1.lat) - (p2.lat - p1.lat) * (latlng.lng - p1.lng);
                        closestResult = { 
                            point: closestPointOnSegment, segmentIndex: i, 
                            offset: minDistance, 
                            direction: Math.abs(crossProduct) < 1e-9 ? 'Ãœzerinde' : crossProduct > 0 ? 'SaÄŸ' : 'Sol' 
                        };
                    }
                }
                return closestResult;
            }

            function calculateDistanceAlongPolyline({ point, segmentIndex }, polyline) {
                let distance = 0;
                const latLngs = polyline.getLatLngs();
                for (let i = 0; i < segmentIndex; i++) { distance += latLngs[i].distanceTo(latLngs[i+1]); }
                distance += latLngs[segmentIndex].distanceTo(point);
                return distance;
            }
            
            initialize();
        });
    </script>
</body>
</html>

