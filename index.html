<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Ã–zmert Adana E5 HaritacÄ±lÄ±k (GeliÅŸmiÅŸ)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.fullscreen/dist/leaflet.fullscreen.css" />
    <style>
        :root {
            --brand-color: #0078d4; --success-color: #107c10; --danger-color: #d13438;
            --light-grey: #f0f0f0; --white: #fff; --shadow: 0 -2px 8px rgba(0,0,0,0.15);
        }
        body, html { 
            margin: 0; padding: 0; height: 100%; width: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            overflow: hidden; 
        }
        #map {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 155px; /* Alt panelin yÃ¼ksekliÄŸi kadar boÅŸluk bÄ±rak */
            background: #e9e9e9;
            cursor: crosshair;
        }
        #bottom-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 155px; /* Sabit yÃ¼kseklik */
            background-color: var(--light-grey);
            box-shadow: var(--shadow);
            border-top: 1px solid #ccc;
            display: flex;
            flex-direction: column;
        }
        #info-container {
            display: flex; justify-content: space-around;
            gap: 10px; padding: 10px; text-align: center;
        }
        .info-box {
            background-color: var(--white); border-radius: 8px;
            padding: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex: 1;
        }
        .info-box .label { font-size: 0.9em; color: #555; font-weight: 600; }
        .info-box .value { 
            color: var(--brand-color); font-size: 1.6em; 
            margin-top: 5px; font-weight: 700;
        }
        .info-box .value.error { color: var(--danger-color); }
        #controls-container {
            display: flex; align-items: stretch;
            padding: 10px; gap: 10px; border-top: 1px solid #ddd;
            flex-shrink: 0;
        }
        .control-group { flex-grow: 1; display: flex; gap: 5px; }
        .control-input {
            width: 100%; border: 1px solid #ccc; border-radius: 8px; 
            padding: 12px; font-size: 1.1em; text-align: center;
        }
        #gpsButton, .control-button {
            padding: 0 20px; font-size: 1.1em; font-weight: bold; color: white;
            border: none; border-radius: 8px; cursor: pointer;
        }
        #goToKmBtn { background-color: var(--brand-color); }
        #gpsButton { background-color: var(--success-color); }
        #gpsButton:disabled { background-color: #6c757d; cursor: not-allowed; }
        
        #crosshair-info {
            position: absolute; top: 10px; left: 50%;
            transform: translateX(-50%); background-color: rgba(43, 43, 43, 0.85);
            color: white; padding: 8px 15px; border-radius: 8px;
            font-size: 1em; font-weight: 600; z-index: 1001;
            pointer-events: none; display: none; box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        #follow-toggle {
            position: absolute; bottom: 165px; right: 10px; z-index: 1000; 
            background: var(--white); border: 2px solid rgba(0,0,0,0.2);
            border-radius: 50%; width: 40px; height: 40px; font-size: 1.8em;
            cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: flex;
            align-items: center; justify-content: center;
        }
        #follow-toggle.active { background-color: var(--brand-color); color: var(--white); }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="crosshair-info"></div>
    <div id="bottom-panel">
        <div id="info-container">
            <div class="info-box">
                <div class="label">Kilometre</div>
                <span class="value" id="kilometre">--.--</span>
            </div>
             <div class="info-box">
                <div class="label">Ofset</div>
                <span class="value" id="ofset">--.--</span>
            </div>
        </div>
        <div id="controls-container">
            <div class="control-group">
                <input type="number" id="km-input" class="control-input" placeholder="KM'ye Git (Ã–rn: 22.5)">
                <button id="goToKmBtn" class="control-button">Git</button>
            </div>
            <button id="gpsButton" disabled>YÃ¼kleniyor...</button>
        </div>
    </div>
    <div id="follow-toggle" class="active" title="Otomatik Takip">ðŸŽ¯</div>

    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.fullscreen/dist/Leaflet.fullscreen.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.5/proj4.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            // DEÄžÄ°ÅžKENLER
            const map = L.map('map', { fullscreenControl: true, contextmenu: true }).setView([37.0, 35.3], 13);
            const kilometreElement = document.getElementById('kilometre'), ofsetElement = document.getElementById('ofset');
            const gpsButton = document.getElementById('gpsButton'), kmInput = document.getElementById('km-input'), goToKmBtn = document.getElementById('goToKmBtn');
            const crosshairInfo = document.getElementById('crosshair-info');
            const followToggle = document.getElementById('follow-toggle');
            let userMarker, routePolyline, startStation, manualMarker, gpsWatcherId, crosshairLine;
            let isAppReady = false; // GÃ¼venlik kilidi
            let isFollowing = true; // Otomatik takip durumu

            // HARÄ°TA KATMANLARI
            const baseLayers = {
                "Sokak": L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: 'Â© OpenStreetMap' }).addTo(map),
                "Uydu": L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { maxZoom: 19, attribution: 'Â© Esri' })
            };
            L.control.layers(baseLayers).addTo(map);
            
            proj4.defs("EPSG:5258", "+proj=tmerc +lat_0=0 +lon_0=36 +k=1 +x_0=500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

            async function initialize() {
                try {
                    const response = await fetch('ADANA-CEYHAN_REV1.xml');
                    if (!response.ok) throw new Error('XML dosyasÄ± bulunamadÄ±!');
                    const xmlText = await response.text();
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                    
                    const alignment = xmlDoc.querySelector('Alignment');
                    if (!alignment) throw new Error('XML dosyasÄ±nda gÃ¼zergah bilgisi (Alignment) bulunamadÄ±.');
                    startStation = parseFloat(alignment.getAttribute('staStart'));
                    
                    let routePoints = [];
                    for (const element of alignment.querySelector('CoordGeom').children) {
                        routePoints.push(...parseElement(element));
                    }
                    routePolyline = L.polyline(routePoints, { color: 'red', weight: 5 }).addTo(map);
                    map.fitBounds(routePolyline.getBounds());
                    
                    gpsButton.addEventListener('click', toggleGps);
                    goToKmBtn.addEventListener('click', goToKm);
                    followToggle.addEventListener('click', toggleFollow);
                    map.on('mousemove', onMapMouseMove);
                    map.on('mouseout', () => { crosshairInfo.style.display = 'none'; if(crosshairLine) map.removeLayer(crosshairLine); });

                    isAppReady = true; 
                    gpsButton.disabled = false;
                    gpsButton.textContent = "BaÅŸlat";
                } catch (error) {
                    alert(`Kritik Hata: ${error.message}`);
                    gpsButton.textContent = "Hata!";
                }
            }

            function toggleGps() {
                if (!isAppReady) return;
                if (gpsWatcherId) {
                    navigator.geolocation.clearWatch(gpsWatcherId);
                    gpsWatcherId = null;
                    gpsButton.textContent = "BaÅŸlat";
                    gpsButton.style.backgroundColor = 'var(--success-color)';
                } else {
                    startGpsTracking();
                }
            }

            function startGpsTracking() {
                if (!navigator.geolocation) { alert("GPS Desteklenmiyor"); return; }
                gpsButton.textContent = "BaÄŸlanÄ±lÄ±yor...";
                gpsButton.disabled = true;

                gpsWatcherId = navigator.geolocation.watchPosition(
                    (position) => {
                        gpsButton.textContent = "Durdur";
                        gpsButton.disabled = false;
                        gpsButton.style.backgroundColor = 'var(--danger-color)';
                        
                        const userLatLng = L.latLng(position.coords.latitude, position.coords.longitude);
                        
                        if (!userMarker) {
                            userMarker = L.circleMarker(userLatLng, { radius: 8, color: 'blue', fillColor: '#3388ff', fillOpacity: 0.8 }).addTo(map);
                        } else {
                            userMarker.setLatLng(userLatLng);
                        }
                        if (isFollowing) {
                            map.setView(userLatLng, 18);
                        }
                        updateCalculations(userLatLng);
                    }, 
                    (error) => {
                        alert("GPS sinyali alÄ±namadÄ± veya izin reddedildi.");
                        toggleGps();
                    }, 
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
                );
            }

            function updateCalculations(userLatLng) {
                if (!isAppReady || !routePolyline || !userLatLng) return;

                kilometreElement.classList.remove('error');
                const closest = findClosestPointOnPolyline(userLatLng, routePolyline);
                
                if (!closest || closest.point === null || closest.segmentIndex < 0) {
                    kilometreElement.textContent = "GÃ¼zergah DÄ±ÅŸÄ±";
                    ofsetElement.textContent = "--.--";
                    kilometreElement.classList.add('error');
                    return;
                }

                const distance = calculateDistanceAlongPolyline(closest, routePolyline);
                if (isNaN(distance)) {
                    kilometreElement.textContent = "HesaplanamadÄ±";
                    kilometreElement.classList.add('error');
                    return;
                }
                
                const currentKm = startStation + distance;
                kilometreElement.textContent = `${(currentKm / 1000).toFixed(3)}`;
                ofsetElement.textContent = `${closest.direction} ${closest.offset.toFixed(1)}m`;
            }

            function onMapMouseMove(e) {
                if (!isAppReady) return;
                try {
                    const closest = findClosestPointOnPolyline(e.latlng, routePolyline);
                    if (!closest || closest.point === null) {
                        crosshairInfo.style.display = 'none';
                        if (crosshairLine) map.removeLayer(crosshairLine);
                        return;
                    }
                    const km = startStation + calculateDistanceAlongPolyline(closest, routePolyline);
                    
                    crosshairInfo.style.display = 'block';
                    crosshairInfo.innerHTML = `KM: ${(km / 1000).toFixed(3)} | Ofset: ${closest.direction} ${closest.offset.toFixed(1)}m`;
                    
                    if (crosshairLine) map.removeLayer(crosshairLine);
                    crosshairLine = L.polyline([e.latlng, closest.point], { color: 'black', weight: 1, dashArray: '5, 5' }).addTo(map);
                } catch(e) {/* Hata gÃ¶sterme */}
            }
            
            function toggleFollow() {
                isFollowing = !isFollowing;
                followToggle.classList.toggle('active', isFollowing);
            }

            // Gerekli yardÄ±mcÄ± fonksiyonlar...
            function findClosestPointOnPolyline(latlng, polyline) {
                const latLngs = polyline.getLatLngs();
                if (!latLngs || latLngs.length < 2) return { point: null, segmentIndex: -1 };
                let minDistance = Infinity;
                let closestResult = { point: null, segmentIndex: -1 };
                for (let i = 0; i < latLngs.length - 1; i++) {
                    const p1 = latLngs[i], p2 = latLngs[i+1];
                    const dx = p2.lng - p1.lng, dy = p2.lat - p1.lat;
                    if (dx === 0 && dy === 0) continue;
                    const t = ((latlng.lng - p1.lng) * dx + (latlng.lat - p1.lat) * dy) / (dx * dx + dy * dy);
                    let closestPointOnSegment = (t < 0) ? p1 : (t > 1) ? p2 : L.latLng(p1.lat + t * dy, p1.lng + t * dx);
                    const dist = latlng.distanceTo(closestPointOnSegment);
                    if (dist < minDistance) {
                        minDistance = dist;
                        const crossProduct = (p2.lng - p1.lng) * (latlng.lat - p1.lat) - (p2.lat - p1.lat) * (latlng.lng - p1.lng);
                        closestResult = { 
                            point: closestPointOnSegment, segmentIndex: i, 
                            offset: minDistance, 
                            direction: Math.abs(crossProduct) < 1e-9 ? 'Ãœzerinde' : crossProduct > 0 ? 'SaÄŸ' : 'Sol' 
                        };
                    }
                }
                return closestResult;
            }

            function calculateDistanceAlongPolyline({ point, segmentIndex }, polyline) {
                if (!point || typeof segmentIndex !== 'number' || segmentIndex < 0) return NaN;
                let distance = 0;
                const latLngs = polyline.getLatLngs();
                for (let i = 0; i < segmentIndex; i++) {
                    distance += latLngs[i].distanceTo(latLngs[i+1]);
                }
                distance += latLngs[segmentIndex].distanceTo(point);
                return distance;
            }

            function goToKm() {
                if (!isAppReady) return;
                const kmValue = parseFloat(kmInput.value);
                if (isNaN(kmValue)) return;
                const km = kmValue * 1000;
                if(manualMarker) map.removeLayer(manualMarker);
                let distance = 0;
                const latLngs = routePolyline.getLatLngs();
                for (let i = 0; i < latLngs.length - 1; i++) {
                    const p1 = latLngs[i], p2 = latLngs[i+1];
                    const segmentDist = p1.distanceTo(p2);
                    if (distance + segmentDist >= (km - startStation)) {
                        const ratio = (km - startStation - distance) / segmentDist;
                        const targetLat = p1.lat + ratio * (p2.lat - p1.lat);
                        const targetLng = p1.lng + ratio * (p2.lng - p1.lng);
                        const targetPoint = L.latLng(targetLat, tLng);
                        manualMarker = L.marker(targetPoint).addTo(map).bindPopup(`KM: ${kmValue.toFixed(3)}`).openPopup();
                        map.setView(targetPoint, 18);
                        return;
                    }
                    distance += segmentDist;
                }
                alert("Girilen KM gÃ¼zergah dÄ±ÅŸÄ±nda!");
            }

            function parseElement(element) {
                let p = [];
                if (element.tagName === 'Line') {
                    const s = element.querySelector('Start').textContent.trim().split(' ').map(Number);
                    const e = element.querySelector('End').textContent.trim().split(' ').map(Number);
                    p.push(proj4('EPSG:5258', 'WGS84', [s[1], s[0]]), proj4('EPSG:5258', 'WGS84', [e[1], e[0]]));
                } else if (element.tagName === 'Curve') {
                    const s = element.querySelector('Start').textContent.trim().split(' ').map(Number);
                    const c = element.querySelector('Center').textContent.trim().split(' ').map(Number);
                    const r = parseFloat(element.getAttribute('radius'));
                    const rot = element.getAttribute('rot');
                    const sA = Math.atan2(s[0] - c[0], s[1] - c[1]);
                    const e = element.querySelector('End').textContent.trim().split(' ').map(Number);
                    const eA = Math.atan2(e[0] - c[0], e[1] - c[1]);
                    let aD = eA - sA;
                    if (rot === 'cw' && aD > 0) aD -= 2 * Math.PI;
                    if (rot === 'ccw' && aD < 0) aD += 2 * Math.PI;
                    const nS = Math.max(10, Math.ceil(Math.abs(aD * r) / 5));
                    for (let i = 0; i <= nS; i++) {
                        const angle = sA + (aD * i) / nS;
                        p.push(proj4('EPSG:5258', 'WGS84', [c[1] + r * Math.cos(angle), c[0] + r * Math.sin(angle)]));
                    }
                }
                return p.map(pt => [pt[1], pt[0]]);
            }
            
            initialize();
        });
    </script>
</body>
</html>
